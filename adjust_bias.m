% adaptive method to calculate bias, does not rely on the result of the optimization problem, slower but yields better resultsfunction [adjusted_bias] = adjust_bias(vars, normal, classes, cl, lb)  % initial approximation for bias  bias = 1;  distances = [];    % for demo plot initial position    graph_data(vars, classes, ['r', 'o'], ['b', '*']);    hold on;    graph(vars, [normal, bias], classes, cl, lb);  % for demo    for i=1:length(vars)    distances(i, :) = [dot(normal, vars(i, :)) + bias, classes(i)];  endfor    % find the closest point to the line  [_, min_index] = min(abs(distances));  closest_class = classes(min_index(1));  % find the closest point of the opposite class  [_, closest_opposite_class] = min(abs(distances()(distances(:, 2) == -closest_class)));  % if opposite class is the negative class add hak=lf the number of classes to get the actual index not the in negative classes  if (closest_class == 1)    closest_opposite_class = floor(length(classes)) / 2 + closest_opposite_class;  endif  % set the line to pass through the closest point of the opposite class  bias = -vars(closest_opposite_class, :)(2) * normal(2) - vars(closest_opposite_class, :)(1) * normal(1);    changed_index = closest_opposite_class;    % move the line to increase margin as long as there is room for it  direction = sign(1 - bias);  while(closest_opposite_class == changed_index(1))    bias = 0.001 * direction + bias;    for i=1:length(vars)      distances(i, :) = [dot(normal, vars(i, :)) + bias, classes(i)];    endfor    % for demo plot after each move      graph(vars, [normal, bias], classes, cl, lb);    % for demo    [_, changed_index] = min(abs(distances));  endwhile    adjusted_bias = bias;  hold off;
endfunction
